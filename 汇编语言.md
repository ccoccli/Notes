# 1 .地址加法器工作原理

- **`物理地址 = 段地址X16 + 偏移地址；`**
- **寻址范围 : 0~FFFFH(64KB), 例如 : 段地址->1000H,则寻址范围为:10000H~1FFFFH;**

# 2.段寄存器

## 1.四个段寄存器：CS, DS, SS, ES

- **当CPU要访问内存时，由这四个段寄存器提供内存单元的段地址;**
- **code segement, data segement, stack segement, extra segement;**
- **cs为代码段寄存器，ip为指令指针寄存器；他们两个指示当前需要从何处取到指令；**
- **在加电启动或者复位后，cs被设置为FFFFH, ip被设置为0000H;所以刚启动时CPU从FFFF0H单元中读取指令并且执行，FFFF0H是开机后的第一条指令；**

## 2.如何改变cs,ip的值？

- **转移指令 ： jmp**
- **格式 ： `jmp 段地址:偏移地址`**
- **仅修改ip的内容：jmp 某一合法寄存器-> `jmp ax`**

## 3.代码段

- **定义：将长度为N(N <= 64KB)的一组代码。存在一组地址连续，起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。**
- **当cs:ip指向了某一段代码段，则该处地址的代码就会被执行；**

# 3.DS和[address]

**1.ds寄存器通常用来访问要访问的数据的段地址；**

```assembly
mov bx, 1000h
mov ds, bx
mov al, [0]
```

**上面三条指令将把10000h(1000:0)中的数据读取到al中；**

**2.mov的功能**

- 直接把数据送入到寄存器：`mov ax, 2`

- 把一个寄存器的内容送入到另外一个寄存器：`mov ax, bx`

- 把一个内存单元中的数据送入一个寄存器：`mov al, [0]`


> 当执行`mov al, [0]`时，会自动取出ds寄存器中的数据当作段地址

**3.段寄存器不可以直接立即数赋值，需要通过通用寄存器来进行赋值；**

> 例如：mov ds. 1000h是错误的
>
> mov ax, 1000h
>
> mov ds, ax是正确的

4.如何将数据从寄存器送入内存单元？

```assembly
mov bx, 1000h
mov ds, bx
mov [0], al
```

上面三条指令把al中的数据存入到10000h(1000:0)的内存单元中；

# 4.mov, add, sub指令

## 1.mov指令

- mov register, data
- mov register, register
- mov register,  memory unit
- mov memory unit, register
- mov segement, register
- mov register, segement

```assembly
mov ax, 6
mov bx, ax
mov ax, [0]
mov [0], ax
mov ds, ax
mov ax, ds
```

## 2.add指令

- add register, data
- add register, register
- add register,  memory unit
- add memory unit, register

```assembly
add ax, 6
add bx, ax
add ax, [0]
add [0], ax
```

## 3.sub指令

- sub register, data
- sub register, register
- sub register,  memory unit
- sub memory unit, register

```assembly
sub ax, 6
sub bx, ax
sub ax, [0]
sub [0], ax
```

## 4.数据段

- **定义：将长度为N(N <= 64KB)的一组代码。存在一组地址连续，起始地址为16的倍数的内存单元中，这段内存是用来存放数据的，从而定义了一个数据段。**
- **当ds:[x]指向了某一段数据段，则该处地址的数据就会被取到；**

# 5.栈

## 1.两个基本操作

### 1.入栈：将一个新元素放到栈顶(push)

### 2.出栈：从栈顶取出一个元素(pop)

**`push ax`->将寄存器ax中的数据送入栈;`pop ax`->从栈顶取出数据送入到ax中。8086CPU的入栈和出栈操作都是以字为单位进行的。**

```assembly
mov  ax, 0123h
push ax
mov  bx, 2266h
push bx
mov  cx, 1122h
push cx
pop  ax
pop  bx
pop  cx
```

## 2.CPU如何知道一段内存空间被当作栈来使用？

- **段寄存器ss用来保存栈顶的段地址，寄存器sp用来保存栈顶的偏移地址；任意时刻ss:sp都是指向栈顶元素。**
- **当执行push操作时，sp = sp -2,然后将数据存入，此时ss:sp都是指向新的栈顶。**
- **当执行pop操作时,先将数据取出来，然后执行 sp = sp + 2**

## 3.栈顶越界问题

- **当栈满时再执行push操作，就会出现栈上溢的情况**
- **当栈空时再执行pop操作，就会出现栈下溢的情况**

## 4.栈段

- **定义：将长度为N(N <= 64KB)的一组代码。存在一组地址连续，起始地址为16的倍数的内存单元中，这段内存将当作栈来使用，从而定义了一个栈段。**
- **当ss:sp指向了某一段栈段，则该处地址的栈的数据就会被取到；**

# 6.第一个程序

- **伪指令(编译器处理)**
- **汇编指令(编译为机器码)**

```assembly
assume cs:codesg

codesg segment

start:  mov ax, 0123h
        mov bx, 0456h
        add ax, bx
        add ax, ax
		
		;实现程序的返回，调用21号中断
        mov ax, 4c00h
        
        int 21h
        
codesg ends

end
```

**示例：编程运算2^3**

```assembly
assume cs:abc

abc segment

    mov ax, 2
    add ax, ax
    add ax, ax

    mov ax, 4c00h
    int 21h
abc ends

end
```

# 7.[bx]和loop指令

## 1.[bx]和内存单元的描述

**相当于数据段的偏移地址在bx中**

```assembly
mov ax, [bx]  -->  ax = ((ds) * 16 + bx)
mov [bx], ax  -->  ((ds) * 16 + bx) = ax
inc bx        -->  (bx)++
```

##  2.loop指令

**`loop`是循环操作，计数器为cx;**

格式：loop 标号

- **①(cx) = (cx) - 1**    
- **②判断cx中的值是否为0，不为0则跳转至标号处执行，否则跳出循环**

**示例1：计算2^11;**

```assembly
assume cs:code

code segment
start:	mov ax, 2
		mov cx, 11

		s: add ax, ax

		loop s

		mov ax, 4c00h
		int 21h
code ends

end
```

**示例2：计算123*236;**

```assembly
assume cs:code

code segment
start:	mov ax, 0
		mov cx, 123

		s: add ax, 236

		loop s

		mov ax, 4c00h
		int 21h
code ends

end
```

**示例3：计算ffff:0006 单元中的数乘以3，结果存储在dx中;**

```assembly
assume cs:code

code segment
;汇编语言数据不能以字母开头，所以要写成0ffffh
start:	mov ax, 0ffffh
		mov ds, ax
		
		mov bx, 6
		mov al, [bx]
		
		mov cx, 3
		
		mov ah, 0
		mov dx, 0
		
		s: add dx, ax
		loop s

		mov ax, 4c00h
		int 21h
code ends

end
```

示例4：将内存2000:0, 2000:1,2000:2,2000:3单元中的数据送入al, bl, cl, dl

```assembly
assume cs:code

code segment
start:	mov ax, 2000h
		mov ds, ax
		
		mov al, ds:[0]
		mov bl, ds:[1]
		mov cl, ds:[2]
		mov dl, ds:[3]

		mov ax, 4c00h
		int 21h
code ends

end
```

示例5：计算ffff:0~ffff:b单元中的数据的和，结果存储在dx中;

```assembly
assume cs:code

code segment
start:	mov ax, 0ffffh
		mov ds, ax
		
		mov cx, b
		mov bx, 0
		
		s:	mov al, [bx]
			mov ah, 0
			add dx, ax
			inc bx
		loop s
		
		mov ax, 4c00h
		int 21h
code ends

end
```

# 8.包含多个段的程序

## 1.dw

> dw:define word
>
> db:define byte

`dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fdeh, 0cbah, 0987h`

示例：对8个数据累加

```assembly
assume cs:code

code segment
	dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fdeh, 0cbah, 0987h 
	mov bx, 0
	mov ax, 0
	mov cx, 8
	s:	add ax, cs:[bx]
		add bx, 2
	loop s
	mov ax, 4c00h
	int 21h
code ends

end
```

## 2.在代码段中使用栈

示例：利用栈，将程序中定义的数据逆序存放;

```assembly
assume cs:code

code segment
	;定义数据
	dw 0123h,0456h,0789h,0abch,0defh,0fdeh,0cbah,0987h 
	;定义栈空间
	dw 0,0,0,0,0,0,0,0
	
start:	mov ax, cs
		mov ss, ax
		mov sp, 20h
		
		mov bx, 0
		mov cx, 8
		s:	push cs:[bx]
			add bx, 2
		loop s
		
		mov bx, 0
		mov cx, 8
		s0:	pop cs:[bx]
			add bx, 2
		loop s0
			
		mov ax, 4c00h
		int 21h
code ends

end start
```

## 3.将数据，代码，栈放入不同的段

示例：利用栈，将程序中定义的数据逆序存放;

```assembly
assume cs:code, ds:data, ss:stack

data segment
	dw 0123h,0456h,0789h,0abch,0defh,0fdeh,0cbah,0987h
data ends

stack segment
	dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:	mov ax, stack
		mov ss, ax
		mov sp, 10h
		
		mov ax, data
		mov ds, ax
		
		mov bx, 0
		mov cx, 8
		s:	push ds:[bx]
			add bx, 2
		loop s
		
		mov bx, 0
		mov cx, 8
		s0:	pop ds:[bx]
			add bx, 2
		loop s0
			
		mov ax, 4c00h
		int 21h
code ends

end start
```

# 9.更多的寻址方式

## 1.and,or,xor,not,sal,shl,shr,sar指令

- **就是逻辑与运算,逻辑或运算,逻辑异或运算,逻辑非运算,算术左移运算,逻辑左移运算，逻辑右移运算，算术右移运算怒(详见C语言笔记逻辑运算)**
- **需要按位运算**

```assembly
mov ax, 1
mov bx, 1

;逻辑与
and ax, bx

;逻辑或
or  ax, bx

;逻辑异或
xor ax, bx

;逻辑非
not ax

;算术左移
sal ah, 1

;逻辑左移
shl ah, 1

;算术右移
sar ah, 1

;逻辑右移
shr ah, 1
```

示例：大小写转换

```assembly
assume cs:code, ds:data, ss:stack

data segment
	db 'BASIC'
	db 'welcometoassembiy'
data ends

code segment
start:	mov ax, data
		mov ds, ax
		
		mov bx,0
		mov cx, 5
		s:	mov al, [bx]
			and al, 11011111b
			mov [bx], al
			
			inc bx
		loop s
		
		mov bx, 5
		mov cs, 11h
		s0:	mov al, [bx]
            or al, 00100000b
            mov [bx], al
            
            inc bx
		loop s0
		
		mov ax, 4c00h
		int 21h
code ends

end start
```

